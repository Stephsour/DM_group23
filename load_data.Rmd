---
title: "Test"
output: html_document
date: "2024-03-05"
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(readr)
library(RSQLite)
```

```{r}
file_path <- "Data/"
#file_path <- "New Data/"
all_files <- list.files(file_path)
```

```{r establish connection}
database_connection <- RSQLite::dbConnect(RSQLite::SQLite(), "zara.db")
```

```{r}
  check_email_format <- function(email_string) {
    pattern <- "^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$"
    return(grepl(pattern, email_string))
  }
  check_date_format <- function(date) {
    pattern <- "^^(0?[1-9]|[12][0-9]|3[01])/(0?[1-9]|1[0-2])/(\\d{4})$"
    return(grepl(pattern, date))
  }
```

```{r message = FALSE, warning = FALSE}
# Validate Customer
if ("Customer.csv" %in% all_files) {
  this_file_path <- paste0(file_path,"Customer.csv")
  file_content <- readr::read_csv(this_file_path)
  
  # save and remove invalid customer data
  invalid_email_rows <- !sapply(file_content$Email, check_email_format)
  valid_customer <- file_content[!invalid_email_rows, ]

  invalid_DOB_rows <- !sapply(valid_customer$DOB, check_date_format)
  valid_customer <- valid_customer[!invalid_DOB_rows,]
  
  # remove duplicated rows
  valid_customer <- valid_customer[!duplicated(valid_customer),]
  
  # adjust format
  valid_customer$DOB <- as.character(as.Date(valid_customer$DOB,format = "%d/%m/%Y"))
  valid_customer$PhoneNumber <- as.character(paste0("+",valid_customer$PhoneNumber))

  RSQLite::dbWriteTable(database_connection, "Customer0", valid_customer, overwrite = T)
  
  insert_query <- paste0("INSERT INTO Customer SELECT * FROM Customer0;")
  RSQLite::dbExecute(database_connection, insert_query)
  
  drop_query <- paste0("DROP TABLE IF EXISTS Customer0;")
  RSQLite::dbExecute(database_connection, drop_query)
}

#Validate Invoice
if ("Invoice.csv" %in% all_files) {
  this_file_path <- paste0(file_path,"Invoice.csv")
  file_content <- readr::read_csv(this_file_path)
  
  # save and remove invalid customer data
  invalid_InvoiceDate_rows <- !sapply(file_content$InvoiceDate, check_date_format)
  valid_invoice <- file_content[!invalid_InvoiceDate_rows,]  
  
  # remove duplicated
  valid_invoice <- valid_invoice[!duplicated(valid_invoice),]
  
  # adjust format of data
  valid_invoice$InvoiceDate <- as.character(as.Date(valid_invoice$InvoiceDate,format = "%d/%m/%Y"))
  
  RSQLite::dbWriteTable(database_connection, "Invoice0", valid_invoice, overwrite = T)

  insert_query <- paste0("INSERT INTO Invoice SELECT * FROM Invoice0;")
  RSQLite::dbExecute(database_connection, insert_query)
  
  drop_query <- paste0("DROP TABLE IF EXISTS Invoice0;")
  RSQLite::dbExecute(database_connection, drop_query)    
}

# Validate Payment
if ("Payment.csv" %in% all_files){
  this_file_path <- paste0(file_path,"Payment.csv")
  file_content <- readr::read_csv(this_file_path)
  
  # save and remove invalid payment records
  invalid_PaymentDate_rows <- !sapply(file_content$PaymentDate, check_date_format)
  valid_payment <- file_content[!invalid_PaymentDate_rows,]
  
  # remove duplicated rows
  valid_payment <- valid_payment[!duplicated(valid_payment),]
  
  # adjust format
  valid_payment$PaymentDate <- as.character(as.Date(valid_payment$PaymentDate,format = "%d/%m/%Y"))
  
  RSQLite::dbWriteTable(database_connection, "Payment0", valid_payment, overwrite = T)

  insert_query <- paste0("INSERT INTO Payment SELECT * FROM Payment0;")
  RSQLite::dbExecute(database_connection, insert_query)
  
  drop_query <- paste0("DROP TABLE IF EXISTS Payment0;")
  RSQLite::dbExecute(database_connection, drop_query)
}

# Validate Sale
if ("Sale.csv" %in% all_files) {
  this_file_path <- paste0(file_path,"Sale.csv")
  file_content <- readr::read_csv(this_file_path)
  
  # save and remove invalid sale data
  invalid_StartDate_rows <- !sapply(file_content$StartDate, check_date_format)
  valid_sale <- file_content[!invalid_StartDate_rows,]  
  
  invalid_EndDate_rows <- !sapply(file_content$EndDate, check_date_format)
  valid_sale <- file_content[!invalid_EndDate_rows,]
  
  # remove duplicated
  valid_sale <- valid_sale[!duplicated(valid_sale),]
  
  # adjust format
  valid_sale$StartDate <- as.character(as.Date(valid_sale$StartDate,format = "%d/%m/%Y"))
  valid_sale$EndDate <- as.character(as.Date(valid_sale$EndDate,format = "%d/%m/%Y"))
  
  RSQLite::dbWriteTable(database_connection, "Sale0", valid_sale, overwrite = T)
  
  insert_query <- paste0("INSERT INTO Sale SELECT * FROM Sale0;")
  RSQLite::dbExecute(database_connection, insert_query)
  
  drop_query <- paste0("DROP TABLE IF EXISTS Sale0;")
  RSQLite::dbExecute(database_connection, drop_query)
}

# Validate Refund
if ("Refund.csv" %in% all_files) {
  this_file_path <- paste0(file_path,"Refund.csv")
  file_content <- readr::read_csv(this_file_path)

  # save and remove invalid refund
  invalid_RefundDate_rows <- !sapply(file_content$RefundDate, check_date_format)
  valid_refund <- file_content[!invalid_RefundDate_rows,]  
  
  # remove duplicated
  valid_refund <- valid_refund[!duplicated(valid_refund),]
  
  # adjust format
  valid_refund$RefundDate <- as.character(as.Date(valid_refund$RefundDate,format = "%d/%m/%Y"))
  
  RSQLite::dbWriteTable(database_connection, "Refund0", valid_refund, overwrite = T)
  
  insert_query <- paste0("INSERT INTO Refund SELECT * FROM Refund0;")
  RSQLite::dbExecute(database_connection, insert_query)
  
  drop_query <- paste0("DROP TABLE IF EXISTS Refund0;")
  RSQLite::dbExecute(database_connection, drop_query)
}

# Validate Supplier
if ("Supplier.csv" %in% all_files) {
  this_file_path <- paste0(file_path,"Supplier.csv")
  file_content <- readr::read_csv(this_file_path)

  # save and remove invalid supplier data
  invalid_contactemail_rows <- !sapply(file_content$ContactEmail, check_email_format)
  valid_supplier <- file_content[!invalid_contactemail_rows, ]

  #remove duplicated
  valid_supplier <- valid_supplier[!duplicated(valid_supplier),]
  
  RSQLite::dbWriteTable(database_connection, "Supplier0", valid_supplier, overwrite = T)
  
  insert_query <- paste0("INSERT INTO Supplier SELECT * FROM Supplier0;")
  RSQLite::dbExecute(database_connection, insert_query)
  
  drop_query <- paste0("DROP TABLE IF EXISTS Supplier0;")
  RSQLite::dbExecute(database_connection, drop_query)
}

# Insert the remaining
remaining <- all_files[!(all_files %in% c("Customer.csv", "Invoice.csv", "Payment.csv", "Sale.csv", "Refund.csv", "Supplier.csv"))]
for (file in remaining) {
  this_file_path <- paste0(file_path,file)
  file_content <- readr::read_csv(this_file_path)
  
  file_content <- file_content[!duplicated(file_content),]
  
  entity <- gsub(".csv","",file)
  table_name <- gsub(".csv","0",file)


  RSQLite::dbWriteTable(database_connection, table_name, file_content, overwrite = T)
  insert_query <- paste0("INSERT INTO ",entity," SELECT * FROM ",table_name,";")
  RSQLite::dbExecute(database_connection, insert_query)
  
  drop_query <- paste0("DROP TABLE IF EXISTS ", table_name,";")
  RSQLite::dbExecute(database_connection, drop_query)

}
```

```{r message = FALSE, warning = FALSE}
# post insert check for duplicated entries
duplicated_custemail <- RSQLite::dbGetQuery(database_connection, 'SELECT "Customer email "||Email||" is repeated."
FROM Customer
GROUP BY Email
HAVING COUNT(*) > 1;')
if (nrow(duplicated_custemail) == 0) {
  print("There are no duplicated customer email.")
} else {
  for (i in 1:nrow(duplicated_custemail)){
    print(duplicated_custemail[i,])
  }
}

duplicated_category <- RSQLite::dbGetQuery(database_connection,
'SELECT "Category name "||CategoryName||" is repeated."
FROM ProductCategory
GROUP BY CategoryName
HAVING COUNT(*) > 1;')
if (nrow(duplicated_category) == 0) {
  print("There are no duplicated category name.")
} else {
  for (i in 1:nrow(duplicated_category)){
    print(duplicated_category[i,])
  }
}

duplicated_supplier <- RSQLite::dbGetQuery(database_connection, 
'SELECT SupplierName, ContactPerson, ContactNumber, ContactEmail||" is repeated."
FROM Supplier
GROUP BY SupplierName, ContactPerson, ContactNumber, ContactEmail
HAVING COUNT(*) > 1;')
if (nrow(duplicated_supplier) == 0) {
  print("There are no duplicated suppliers.")
} else {
  for (i in 1:nrow(duplicated_supplier)){
    print(duplicated_supplier[i,])
  }
}

duplicated_saleevent <- RSQLite::dbGetQuery(database_connection, 
'SELECT EventName, DiscountPercentage, StartDate, EndDate||" is repeated."
FROM Sale
GROUP BY EventName, DiscountPercentage, StartDate, EndDate
HAVING COUNT(*) > 1;')
if (nrow(duplicated_saleevent) == 0) {
  print("There are no duplicated sale events.")
} else {
  for (i in 1:nrow(duplicated_saleevent)){
    print(duplicated_saleevent[i,])
  }
}

duplicated_transref <- RSQLite::dbGetQuery(database_connection, 
'SELECT TransactionRef||" is repeated."
FROM Refund
WHERE TransactionRef NOT NULL
GROUP BY TransactionRef
HAVING COUNT(*) > 1;')
if (nrow(duplicated_transref) == 0) {
  print("There are no duplicated refund transaction reference.")
} else {
  for (i in 1:nrow(duplicated_transref)){
    print(duplicated_transref[i,])
  }
}

duplicated_trackingid <- RSQLite::dbGetQuery(database_connection, 
'SELECT TrackingID||" is repeated."
FROM Invoice
WHERE TrackingID NOT NULL
GROUP BY TrackingID
HAVING COUNT(*) > 1;')
if (nrow(duplicated_trackingid) == 0) {
  print("There are no duplicated tracking IDs.")
} else {
  for (i in 1:nrow(duplicated_trackingid)){
    print(duplicated_trackingid[i,])
  }
}
```

```{r message = FALSE, warning = FALSE}
# post insertion check for entry error
incorrect_sale <- RSQLite::dbGetQuery(database_connection, 
'SELECT SaleID || " has end date before start date."
FROM Sale
WHERE StartDate > EndDate;')
if (nrow(incorrect_sale) == 0) {
  print("There are no entry errors in sale event dates.")
} else {
  for (i in 1:nrow(incorrect_sale)){
    print(incorrect_sale[i,])
  }
}

incorrect_refdate <- RSQLite::dbGetQuery(database_connection, 
'SELECT R.RefundID || " should not be approved as refund is not requested within 30 days."
FROM Refund AS R INNER JOIN Purchase AS P
  ON R.RefundID = P.RefundID INNER JOIN Invoice AS I
  ON P.InvoiceNumber = I.InvoiceNumber
WHERE R.RefundDate > DATE(I.InvoiceDate, "+30 days");')
if (nrow(incorrect_refdate) == 0) {
  print("There are no entry errors in refund date.")
} else {
  for (i in 1:nrow(incorrect_refdate)){
    print(incorrect_refdate[i,])
  }
}

incorrect_refquantity <- RSQLite::dbGetQuery(database_connection,
'SELECT R.RefundID || " has entry error as refund quantity should be less than or equal to purchase quantity."
FROM Refund AS R INNER JOIN Purchase as P
  ON R.RefundID = P.RefundID
WHERE R.RefundQuantity > P.Quantity;')
if (nrow(incorrect_refquantity) == 0) {
  print("There are no entry errors in refund quantity.")
} else {
  for (i in 1:nrow(incorrect_refquantity)){
    print(incorrect_refquantity[i,])
  }
}

incorrect_refund <- RSQLite::dbGetQuery(database_connection, 
'SELECT "Refund should not be available for "|| P.ProductID ||" in invoice "||P.InvoiceNumber||"."
FROM Purchase as P INNER JOIN Invoice as I
  ON P.InvoiceNumber = I.InvoiceNumber
WHERE I.Status != "Completed" AND P.RefundID NOT NULL;')
if (nrow(incorrect_refund) == 0) {
  print("There are no invalid refunds.")
} else {
  for (i in 1:nrow(incorrect_refund)){
    print(incorrect_refund[i,])
  }
}

incorrect_invpstatus <- RSQLite::dbGetQuery(database_connection,
'SELECT I.InvoiceNumber || " should be cancelled as payment is not settled within two days."
FROM Invoice AS I INNER JOIN Payment as P
  ON I.InvoiceNumber = P.InvoiceNumber
WHERE DATE(I.InvoiceDate, "+2 days") < P.PaymentDate;')
if (nrow(incorrect_invpstatus) == 0) {
  print("There are no entry errors in invoice status.")
} else {
  for (i in 1:nrow(incorrect_invpstatus)){
    print(incorrect_invpstatus[i,])
  }
}

incorrect_invstatus <- RSQLite::dbGetQuery(database_connection, 
'SELECT I.InvoiceNumber||" should be cancelled or pending for payment as payment is declined."
FROM Invoice AS I INNER JOIN Payment AS P
  ON I.InvoiceNumber = P.InvoiceNumber
WHERE (I.Status != "Cancelled" AND I.Status != "Pending for Payment") 
  AND P.PaymentStatus = "Payment Declined";')
if (nrow(incorrect_invstatus) == 0) {
  print("There are no entry errors in invoice status.")
} else {
  for (i in 1:nrow(incorrect_invstatus)){
    print(incorrect_invstatus[i,])
  }
}

```

```{r}
RSQLite::dbDisconnect(database_connection)
```




